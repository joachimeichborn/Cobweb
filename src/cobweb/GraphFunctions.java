/*
	Cobweb
	Copyright (C) 2010 Joachim von Eichborn
 
    This file is part of Cobweb.

    Cobweb is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Cobweb is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Cobweb.  If not, see <http://www.gnu.org/licenses/>.
 */

package cobweb;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import particlesystem.Edge;
import particlesystem.Node;
import particlesystem.ParticleSystem;

/**
 * Graph functions to perform graph analysis like shortest path
 * 
 * @author Joachim von Eichborn
 * @author http://bioinformatics.charite.de/cobweb
 * @version 1.1.0
 */
public class GraphFunctions {

	/**
	 * Return a list of nodes that lie on the path to the given node
	 * 
	 * @param predecessor
	 *            A list of predessors of nodes, generated by a breadth first
	 *            search
	 * @param curNode
	 *            The node whose predecessors in the path are returned
	 * @return The list of nodes on the path to the given node
	 */
	static ArrayList<Node> bfsGetPredecessor (HashMap<Node, ArrayList<Node>> predecessor, Node curNode) {
		ArrayList<Node> path = new ArrayList<Node>();

		path.add(curNode);

		if (predecessor.get(curNode) != null) {
			for (int i = 0; i < predecessor.get(curNode).size(); ++i)
				path.addAll(bfsGetPredecessor(predecessor, predecessor.get(curNode).get(i)));
		}

		return path;
	}

	/**
	 * Find one shortest path between the start and sink node
	 * 
	 * @param ps
	 *            The particle system
	 * @param start
	 *            The start node
	 * @param sink
	 *            The sink node
	 * @return The list of nodes that are on one shortest path from the start
	 *         node to the sink node
	 */
	static ArrayList<Node> breadthFirstSearch (ParticleSystem ps, Node start, Node sink) {

		HashMap<Node, Integer> seen = new HashMap<Node, Integer>();
		HashMap<Node, Node> predecessor = new HashMap<Node, Node>();
		ArrayList<Node> queue = new ArrayList<Node>();

		seen.put(start, 0);
		predecessor.put(start, null);
		queue.add(start);

		while (!queue.isEmpty()) {
			Node u = queue.get(0);
			queue.remove(0);

			for (int i = 0; i < ps.numberOfEdges(); ++i) {
				Edge e = ps.getEdge(i);
				if (e.getSource().equals(u)) {
					if (!seen.containsKey(e.getTarget())) {
						queue.add(e.getTarget());
						seen.put(e.getTarget(), seen.get(e.getSource()) + 1);
						predecessor.put(e.getTarget(), e.getSource());
					}
				}

				if (!ps.isDirected()) {
					if (e.getTarget().equals(u)) {
						if (!seen.containsKey(e.getSource())) {
							queue.add(e.getSource());
							seen.put(e.getSource(), seen.get(e.getTarget()) + 1);
							predecessor.put(e.getSource(), e.getTarget());
						}
					}
				}
			}

		}

		ArrayList<Node> path = new ArrayList<Node>();
		Node curNode = sink;

		while (predecessor.get(curNode) != null) {
			path.add(curNode);
			curNode = predecessor.get(curNode);
		}

		return path;
	}

	/**
	 * Find all shortest path between the start and sink node
	 * 
	 * @param ps
	 *            The particle system
	 * @param start
	 *            The start node
	 * @param sink
	 *            The sink node
	 * @return The list of nodes that are on all shortest paths from the start
	 *         node to the sink node
	 */
	static ArrayList<Node> breadthFirstSearchAllPaths (ParticleSystem ps, Node start, Node sink) {

		HashMap<Node, Integer> seen = new HashMap<Node, Integer>();
		HashMap<Node, ArrayList<Node>> predecessor = new HashMap<Node, ArrayList<Node>>();
		ArrayList<Node> queue = new ArrayList<Node>();

		seen.put(start, 0);
		predecessor.put(start, null);
		queue.add(start);

		while (!queue.isEmpty()) {
			Node u = queue.get(0);
			queue.remove(0);

			for (int i = 0; i < ps.numberOfEdges(); ++i) {
				Edge e = ps.getEdge(i);
				if (e.getSource().equals(u)) {
					if ((!seen.containsKey(e.getTarget())) || (seen.get(e.getTarget()) == seen.get(e.getSource()) + 1)) {
						queue.add(e.getTarget());
						seen.put(e.getTarget(), seen.get(e.getSource()) + 1);
						if (predecessor.containsKey(e.getTarget()))
							predecessor.get(e.getTarget()).add(e.getSource());
						else {
							ArrayList<Node> tmp = new ArrayList<Node>();
							tmp.add(e.getSource());
							predecessor.put(e.getTarget(), tmp);
						}
					}
				}

				if (!ps.isDirected()) {
					if (e.getTarget().equals(u)) {
						if ((!seen.containsKey(e.getSource())) || (seen.get(e.getSource()) == seen.get(e.getTarget()) + 1)) {
							queue.add(e.getSource());
							seen.put(e.getSource(), seen.get(e.getTarget()) + 1);
							if (predecessor.containsKey(e.getSource()))
								predecessor.get(e.getSource()).add(e.getTarget());
							else {
								ArrayList<Node> tmp = new ArrayList<Node>();
								tmp.add(e.getTarget());
								predecessor.put(e.getSource(), tmp);
							}
						}
					}
				}
			}

		}

		ArrayList<Node> path = new ArrayList<Node>();
		Node curNode = sink;

		if (predecessor.get(curNode) != null) {
			path.add(curNode);
			for (int i = 0; i < predecessor.get(curNode).size(); ++i)
				path.addAll(bfsGetPredecessor(predecessor, predecessor.get(curNode).get(i)));
		}

		return path;
	}

	/**
	 * Return a list of lists of nodes, each list of nodes represents one
	 * connected component
	 * 
	 * @param ps
	 *            The particle system
	 * @return The list of lists of nodes, each list of nodes represents one
	 *         connected component
	 */
	static ArrayList<ArrayList<Node>> connectedComponents (ParticleSystem ps) {
		ArrayList<ArrayList<Node>> components = new ArrayList<ArrayList<Node>>();

		for (int i = 0; i < ps.numberOfNodes(); ++i) {
			ArrayList<Node> tmp = new ArrayList<Node>();
			tmp.add(ps.getNode(i));
			components.add(tmp);
		}

		for (int i = 0; i < ps.numberOfEdges(); ++i) {
			int c1 = 0, c2 = 0;

			for (int x = 0; x < components.size(); ++x)
				if (components.get(x).contains(ps.getEdge(i).getSource())) {
					c1 = x;
					break;
				}

			for (int y = 0; y < components.size(); ++y)
				if (components.get(y).contains(ps.getEdge(i).getTarget())) {
					c2 = y;
					break;
				}

			if (c1 != c2) {
				components.get(c1).addAll(components.get(c2));
				components.remove(c2);
			}
		}

		return components;
	}

	/**
	 * Return all neighbours of the currently selected nodes
	 * 
	 * @param ps
	 *            The particle system
	 * @return The list of all neighbours of the selected nodes
	 */
	static ArrayList<Node> getAllNeighbours (ParticleSystem ps) {
		Edge e = null;

		ArrayList<Node> neighbours = new ArrayList<Node>();

		for (int i = 0; i < ps.numberOfSelectedNodes(); ++i) {
			for (int j = 0; j < ps.numberOfEdges(); ++j) {
				e = ps.getEdge(j);

				if (e.getSource().equals(ps.getSelectedNode(i)))
					neighbours.add(e.getTarget());
				else if (e.getTarget().equals(ps.getSelectedNode(i)))
					neighbours.add(e.getSource());
			}
		}

		return neighbours;
	}

	/**
	 * Return the common neighbours of the currently selected nodes
	 * 
	 * @param ps
	 *            The particle system
	 * @return The list of common neighbours of the selected nodes
	 */
	static ArrayList<Node> getCommonNeighbours (ParticleSystem ps) {
		ArrayList<Node> neighbours = new ArrayList<Node>();

		if (ps.numberOfSelectedNodes() <= 1)
			return getAllNeighbours(ps);

		Node n = ps.getSelectedNode(0);
		Edge e = null;

		// Add all neighbours of the first selected node to the neighbours list
		for (int i = 0; i < ps.numberOfEdges(); ++i) {
			e = ps.getEdge(i);

			if (e.getSource().equals(n))
				neighbours.add(e.getTarget());
			else if (e.getTarget().equals(n))
				neighbours.add(e.getSource());
		}

		Node n2 = null;
		boolean isNeighbour = false;

		// Delete nodes from the neighbourslist that are not neighbours of other
		// selected nodes
		Iterator<Node> neighboursIt = neighbours.iterator();
		while (neighboursIt.hasNext()) {
			n = neighboursIt.next();

			for (int i = 1; i < ps.numberOfSelectedNodes(); ++i) {
				n2 = ps.getSelectedNode(i);
				isNeighbour = false;

				for (int j = 0; j < ps.numberOfEdges(); ++j) {
					e = ps.getEdge(j);

					if ((e.getSource().equals(n) && e.getTarget().equals(n2)) || (e.getSource().equals(n2) && e.getTarget().equals(n)))
						isNeighbour = true;
				}

				if (!isNeighbour) {
					neighboursIt.remove();
					break;
				}
			}
		}

		return neighbours;
	}

}
